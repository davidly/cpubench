; Z80 assembly to compute e to n digits.
; When DIGITS is 200, the first 192 digits are displayed.
;
; equivalent to:
;     program e;
;     const
;        DIGITS = 200;
;     type
;         arrayType = array[ 0..DIGITS ] of integer;
;     var 
;         high, n, x : integer;
;         a : arrayType;
;     begin
;         high := DIGITS;
;         x := 0;
;         n := high - 1;
;         while n > 0 do begin
;             a[ n ] := 1;
;             n := n - 1;
;         end;
;     
;         a[ 1 ] := 2;
;         a[ 0 ] := 0;
;     
;         while high > 9 do begin
;             high := high - 1;
;             n := high;
;             while 0 <> n do begin
;                 a[ n ] := x MOD n;
;                 x := 10 * a[ n - 1 ] + x DIV n;
;                 n := n - 1;
;             end;
;     
;             Write( x );
;         end;
;     
;         writeln; writeln( 'done' );
;     end.

; cp/m-specific constants

BDOS  equ 5
BdosDisplayChar EQU 2         ; c register function to print a character
BdosPrintString EQU 9         ; c register function to print a $ terminated string

; app constants

true   equ 1
false  equ 0
digits equ 200

aseg
org     100h
        ; why is the loop backwards? no idea.
        ; while n > 0 do begin
        ;     a[ n ] := 1;
        ;     n := n - 1;
        ; end;

        ; register c is n. hl is a[]. b is a constant 1

        ld         b, 1
        ld         c, DIGITS - 1
        ld         hl, array + DIGITS - 1

  ainit:
        ld         (hl), b
        dec        hl
        dec        c
        jp         nz, ainit

        ; a[ 1 ] := 2;
        ; a[ 0 ] := 0;

        ld         hl, array + 1
        ld         (hl), 2
        dec        hl
        ld         (hl), 0

        ; register c is n. register b is high. register hl is x at the start of each inner loop
       
        ld         b, DIGITS

  outerloop:
        dec        b                ; high := high - 1; n := high
        push       bc               ; save b/high on the stack
        ld         de, 0            ; x := 0;
        ld         h, d             ; n := high

  innerloop:
        ld         l, b
        call       udiv             ; computes both x MOD n and x DIV n.  hl = de / hl. remainder in de
        ld         c, l             ; save division result in c
        ld         a, e             ; remainder in de is just in 

        ld         hl, array
        ld         e, b
        add        hl, de
        ld         (hl), a          ; a[ n ] := x MOD n;

        dec        hl               ; make hl point to a[ n - 1 ]
        ld         e, (hl)          ; put a[ n - 1 ] in de

        ex         de, hl
        add        hl, hl           ; double hl ( a[ n - 1 ] )
        ld         d, h             ; save the 2x amount
        ld         e, l
        add        hl, hl           ; now it's 4x
        add        hl, hl           ; now it's 8x
        add        hl, de           ; now it's 10x

        ld         d, 0
        ld         e, c
        add        hl, de           ; add the two parts together

        ex         de, hl
        dec        b                ; n := n - 1;
        jp         nz, innerloop    ; if n isn't 0 then loop again

        call       DisplayUnsigned  ; show the next digit(s) of e
        
        ld         a, 9
        pop        bc
        cp         b                ; while high > 9 do begin (re-written as a do until loop)
        jp         nz, outerloop

        ld         hl, CRLF
        call       display
        ld         hl, STRDONE
        call       display
        ret                         ; return to CP/M

DisplayUnsigned:                    ; print the usigned 16-bit number in hl
        push    bc
        push    de
        push    hl
        call    PrintUnsigned
        pop     hl
        pop     de
        pop     bc
        ret

PrintUnsigned:                      ; print the unsigned 16-bit number in HL
        ld      de, NUM             ; Load pointer to end of number string
        push    de                  ; Onto the stack
        ld      bc, -10             ; Divide by ten (by trial subtraction)
  PU$DIGIT:
        ld      de, -1              ; DE = quotient. There is no 16-bit subtraction,
  PU$DGTDIV:
        add     hl, bc              ; so we just add a negative value,
        inc     de
        jp      c, PU$DGTDIV        ; while that overflows.
        ld      a, '0'+10           ; The loop runs once too much so we're 10 out
        add     a, l                ; The remainder (minus 10) is in L
        ex      (sp), hl            ; Swap HL with top of stack (i.e., the string pointer)
        dec     hl                  ; Go back one byte
        ld      (hl), a             ; And store the digit
        ex      (sp), hl            ; Put the pointer back on the stack
        ex      de, hl              ; Do all of this again with the quotient
        ld      a, h                ; If it is zero, we're done
        or      l
        jp      nz, PU$DIGIT        ; But if not, there are more digits
        ld      c, BdosPrintString  ; Prepare to call CP/M and print the string
        pop     de
        jp      bdos                ; And only then print the string. bdos will return to caller

DisplayOneCharacter:                ; display the character in a
        push    bc
        push    de
        push    hl
        ld      c, BdosDisplayChar
        ld      e, a
        call    BDOS

        pop     hl
        pop     de
        pop     bc
        ret

Display:                      ; display null-terminated string pointed to by hl
        push    hl
        push    de
        push    bc

        ld      b, h
        ld      c, l

  DSNext:
        ld      a, (bc)
        cp      0
        jp      z, DSDone
        call    DisplayOneCharacter
        inc     bc
        jp      DSNext

  DSDone:
        pop     bc
        pop     de
        pop     hl
        ret

; unsigned divide de by hl, result in hl. remainder in divRem. divide by 0 not checked.
udiv:
        ld      a, e
        or      d
        jp      nz, udiv$notzero
        ld      hl, 0
        ret
  udiv$notzero:
        push    bc
        ex      de, hl
        ld      bc, 0
  udiv$loop:
        sbc     hl, de
        jp      c, udiv$done
        inc     bc
        jp      udiv$loop
  udiv$done:
        add     hl, de
        ex      de, hl              ; Do all of this again with the quotient
        ld      l, c
        ld      h, b
        pop     bc
        ret

            db      '00000'            
NUM:        db      '$'             ; Space for number. cp/m strings end with a dollar sign
CRLF:       db      13,10,0
STRDONE:    db      'done.', 13, 10, 0
ARRAY:      ds      DIGITS

end

