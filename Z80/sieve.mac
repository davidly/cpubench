; Z80 version of BYTE's sieve
; replicate this:
;        #define TRUE 1
;        #define FALSE 0
;        #define SIZE 8190
;        
;        char flags[SIZE+1];
;        
;        int main()
;                {
;                int i,k;
;                int prime,count,iter;
;        
;                for (iter = 1; iter <= 10; iter++) {    /* do program 10 times */
;                        count = 0;                      /* initialize prime counter */
;                        for (i = 0; i <= SIZE; i++)     /* set all flags true */
;                                flags[i] = TRUE;
;                        for (i = 0; i <= SIZE; i++) {
;                                if (flags[i]) {         /* found a prime */
;                                        prime = i + i + 3;      /* twice index + 3 */
;                                        for (k = i + prime; k <= SIZE; k += prime)
;                                                flags[k] = FALSE;       /* kill all multiples */
;                                        count++;                /* primes found */
;                                        }
;                                }
;                        }
;                printf("%d primes.\n",count);           /*primes found in 10th pass */
;                return 0;
;                }
;

; cp/m-specific constants

BDOS            equ 5
BdosDisplayChar equ 2         ; c register function to print a character
BdosPrintString equ 9         ; c register function to print a $ terminated string

; app constants

true   equ 1
false  equ 0
loops  equ 10
size   equ 8190

sizehi equ size SHR 8
sizelo equ size AND 0ffh

sizep1hi equ ( size + 1 ) SHR 8
sizep1lo equ ( size + 1 ) AND 0ffh

  aseg
org     100h
        jp         actualcode       ; put data before code to satisfy the m80 assembler, which can't resolve the symbols otherwise

        PKFLAGS:    dw      0               ; address of flags[ k ]
        COUNT:      dw      0               ; count in C code
        ITER:       dw      0               ; iter in C code
        SaveSP:     dw      0               ; temporarily save SP here

        NEGF:       db      0               ; Space for negative flag
                    db      '-00000'            
        NUM:        db      '$'             ; Space for number. cp/m strings end with a dollar sign
        CRLF:       db      13,10,0
        STRPRIMES:  db     ' primes.', 13, 10, 0
        
actualcode:
  iteragain:                        ; for ( iter = 1; iter <= 10; iter++ )
        ld         hl, 0            ; count = 0
        ld         (COUNT), hl

        ; set all array entries to true:  for (i = 0; i <= SIZE; i++) flags[i] = TRUE;

        ld         hl, flags
        ld         (hl), 1
        ld         d, h
        ld         e, l
        inc        de
        ld         bc, size+2
        ldir

        ; iterate through array entries and count primes
        ; register usage:
        ;    bc:    i in the for loop
        ;    de:    prime
        ;    hl:    & flags[ i ]

  nextprime:
        ld         hl, flags
        add        hl, bc
        ld         d, b             ; save the current i in de
        ld         e, c
        ld         bc, 0            ; a value of 1 will be found, even if it's 1 byte past the end of the array
        ld         a, 1
        cpir

        inc        bc               ; bc and hl are modified even if there is a match on the first byte
        dec        hl
        ex         de, hl           ; update bc to be the i. first save hl for later
        sbc        hl, bc
        ld         b, h
        ld         c, l
        ex         de, hl           ; restore hl -- & flags[ i ]

        ld         a, 20h           ; did we go past the end of the array?
        cp         b
        jp         z, checknextiter

  flagison:
        ex         de, hl
        ld         hl, 3
        add        hl, bc
        add        hl, bc
        ex         de, hl           ; de is prime

        ld         a, 22h           ; flags goes from 0x0300 to 0x22ff. 0x2300 means we're past the array
        add        hl, de
        cp         h
        jp         c, inccount

  kloop:                            ; hl = pointer to k'th element in flags. dc = prime
        ld         (hl), 0          ; flags[ k ] = false
        add        hl, de           ; k += prime
        cp         h
        jp         nc, kloop

  inccount:                         
        ld         hl, (COUNT)      ; count++
        inc        hl
        ld         (COUNT), hl

  flagisoff:                        ; check if outer loop is done
        inc        bc
        ld         a, 20h           ; past 8192 byes?
        cp         b
        jp         nz, nextprime

  checknextiter:                    ; are we done iterating loops times?
        ld         a, (ITER)
        inc        a
        ld         (ITER), a
        cp         loops
        jp         nz, iteragain

        ld         hl, (COUNT)      ; print the count of primes and the string
        call       PrintUnsigned
        ld         hl, STRPRIMES
        call       DisplayString

        ret                         ; return to CP/M

DisplayOneCharacter:                ; display the character in a
        push    bc
        push    de
        push    hl

        ld      c, BdosDisplayChar
        ld      e, a
        call    BDOS

        pop     hl
        pop     de
        pop     bc
        ret

DisplayString:                      ; display null-terminated string pointed to by hl
        push    hl
        push    de
        push    bc

        ld      b, h
        ld      c, l

  DSNext:
        ld      a, (bc)
        cp      0
        jp      z, DSDone
        call    DisplayOneCharacter
        inc     bc
        jp      DSNext

  DSDone:
        pop     bc
        pop     de
        pop     hl
        ret

PrintUnsigned:                      ; print the unsigned 16-bit number in HL
        ld      de, NUM             ; Load pointer to end of number string
        push    de                  ; Onto the stack
        ld      bc, -10             ; Divide by ten (by trial subtraction)
  PU$DIGIT:
        ld      de, -1              ; DE = quotient. There is no 16-bit subtraction,
  PU$DGTDIV:
        add     hl, bc              ; so we just add a negative value,
        inc     de
        jp      c, PU$DGTDIV        ; while that overflows.
        ld      a, '0'+10           ; The loop runs once too much so we're 10 out
        add     a, l                ; The remainder (minus 10) is in L
        ex      (sp), hl            ; Swap HL with top of stack (i.e., the string pointer)
        dec     hl                  ; Go back one byte
        ld      (hl), a             ; And store the digit
        ex      (sp), hl            ; Put the pointer back on the stack
        ex      de, hl              ; Do all of this again with the quotient
        ld      a, h                ; If it is zero, we're done
        or      l
        jp      nz, PU$DIGIT        ; But if not, there are more digits
        ld      c, BdosPrintString  ; Prepare to call CP/M and print the string
        pop     de
        jp      bdos                ; And only then print the string. bdos will return to caller

org 2300h-8192
        flags:      ds      size + 1
        afterflags: db      69h             ; make it easy to find. will be 1 after initialization to terminate cpir

end

